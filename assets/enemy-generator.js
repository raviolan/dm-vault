// enemy-generator.js
// Lightweight enemy generator: Open5e + homebrew, save via /api/create-page (preferred), fallback to localStorage

const form = document.getElementById('enemy-form');
const resultSection = document.getElementById('enemy-result');
// assets/enemy-generator.js
// Clean, single-file enemy generator for the site.
// - Generates from Open5e or local /assets/homebrew-enemies.json
// - Renders result into #enemy-result
// - Saves via POST /api/create-page (preferred) with fallback to localStorage

(function () {
    'use strict';

    const NAV_SAVED_ID = 'navEnemySavedList';

    function levelToCR(level) {
        if (level < 3) return 0.25;
        if (level < 5) return 1;
        if (level < 7) return 2;
        if (level < 9) return 3;
        if (level < 11) return 5;
        if (level < 13) return 7;
        if (level < 15) return 9;
        if (level < 17) return 12;
        if (level < 19) return 15;
        return 18;
    }

    function escapeHtml(str) {
        return String(str || '').replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[c]);
    }

    function capitalize(s) { return (s || '').charAt(0).toUpperCase() + (s || '').slice(1); }

    async function checkBackend(timeout = 800) {
        try {
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeout);
            const r = await fetch('/api/enemies', { signal: controller.signal });
            clearTimeout(id);
            return r.ok;
        } catch (e) {
            return false;
        }
    }

    function buildContentFragment(monster, level, enemyClass) {
        const actionsHtml = (monster.actions && monster.actions.length)
            ? monster.actions.map(a => `<li><strong>${escapeHtml(a.name)}</strong>: ${escapeHtml(a.desc || '')}</li>`).join('\n')
            : '<li>None listed</li>';

        return `
            <h1>${escapeHtml(monster.name)} (Level ${level} ${escapeHtml(capitalize(enemyClass))})</h1>
            <p class="meta">#enemy</p>
            <p><strong>Type:</strong> ${escapeHtml(monster.type || '')} | <strong>CR:</strong> ${escapeHtml(String(monster.challenge_rating || ''))}</p>
            <p><strong>HP:</strong> ${escapeHtml(String(monster.hit_points || ''))} | <strong>AC:</strong> ${escapeHtml(String(monster.armor_class || ''))}</p>
            <p><strong>Alignment:</strong> ${escapeHtml(monster.alignment || '')}</p>
            <h2>Abilities</h2>
            <p>STR ${escapeHtml(String(monster.strength || ''))}, DEX ${escapeHtml(String(monster.dexterity || ''))}, CON ${escapeHtml(String(monster.constitution || ''))}, INT ${escapeHtml(String(monster.intelligence || ''))}, WIS ${escapeHtml(String(monster.wisdom || ''))}, CHA ${escapeHtml(String(monster.charisma || ''))}</p>
            <h2>Actions</h2>
            <ul>${actionsHtml}</ul>
            <p style="font-style:italic;">Generated by Enemy Generator</p>
        `;
    }

    function renderEnemyInto(container, monster, level, enemyClass) {
        const actionsHtml = (monster.actions && monster.actions.length)
            ? monster.actions.map(a => `<li><strong>${escapeHtml(a.name)}</strong>: ${escapeHtml(a.desc || '')}</li>`).join('\n')
            : '<li>None listed</li>';

        container.innerHTML = `
            <h2>${escapeHtml(monster.name)} (Level ${level} ${escapeHtml(capitalize(enemyClass))})</h2>
            <p><strong>Type:</strong> ${escapeHtml(monster.type || '')} | <strong>CR:</strong> ${escapeHtml(String(monster.challenge_rating || ''))}</p>
            <p><strong>HP:</strong> ${escapeHtml(String(monster.hit_points || ''))} | <strong>AC:</strong> ${escapeHtml(String(monster.armor_class || ''))}</p>
            <p><strong>Alignment:</strong> ${escapeHtml(monster.alignment || '')}</p>
            <p><strong>Abilities:</strong> STR ${escapeHtml(String(monster.strength || ''))}, DEX ${escapeHtml(String(monster.dexterity || ''))}, CON ${escapeHtml(String(monster.constitution || ''))}, INT ${escapeHtml(String(monster.intelligence || ''))}, WIS ${escapeHtml(String(monster.wisdom || ''))}, CHA ${escapeHtml(String(monster.charisma || ''))}</p>
            <p><strong>Actions:</strong></p>
            <ul>${actionsHtml}</ul>
            <p style="font-style:italic;">(Flavor as a level ${level} ${escapeHtml(capitalize(enemyClass))} for your campaign!)</p>
            <div style="margin-top:1em;"><button id="save-enemy-btn" class="btn-primary">Save as Page</button></div>
        `;

        const saveBtn = container.querySelector('#save-enemy-btn');
        if (saveBtn) saveBtn.addEventListener('click', () => showSaveModal(monster, level, enemyClass));
    }

    function showSaveModal(monster, level, enemyClass) {
        const defaultName = (monster && monster.name) ? monster.name.replace(/[^a-zA-Z0-9\s_-]/g, '') : `Enemy_${Date.now()}`;
        const title = prompt('Page title for saved enemy:', defaultName);
        if (!title) return;
        const type = prompt('Page type (npc, tool, etc). Recommended: "npc"', 'npc') || 'npc';
        const content = buildContentFragment(monster, level, enemyClass);
        saveViaCreatePage(type, title, content);
    }

    async function saveViaCreatePage(type, title, content) {
        const statusId = 'eg-save-status';
        const resultSec = document.getElementById('enemy-result');
        if (!resultSec) return;
        let statusEl = document.getElementById(statusId);
        if (!statusEl) {
            resultSec.insertAdjacentHTML('beforeend', `<p id="${statusId}">Saving...</p>`);
            statusEl = document.getElementById(statusId);
        } else {
            statusEl.textContent = 'Saving...';
        }

        try {
            const res = await fetch('/api/create-page', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ type, title, content })
            });

            if (res.status === 409) {
                if (!confirm('A page with that name already exists. Choose a different title?')) {
                    statusEl.textContent = 'Save cancelled.';
                    return;
                }
                const newTitle = prompt('New page title:', title + ' (copy)');
                if (newTitle) return saveViaCreatePage(type, newTitle, content);
                statusEl.textContent = 'Save cancelled.';
                return;
            }

            if (!res.ok) throw new Error('create-failed');
            const data = await res.json();
            // remember generator-created pages so Saved subsection only contains generator items
            try {
                const gs = JSON.parse(localStorage.getItem('generatorSavedPages') || '[]');
                gs.unshift({ name: title, href: data.url });
                localStorage.setItem('generatorSavedPages', JSON.stringify(gs.slice(0, 200)));
            } catch (e) { /* ignore */ }
            statusEl.outerHTML = `<p style="color:var(--success,#0a0);">Saved to site — <a href="${data.url}">${escapeHtml(title)}</a></p>`;
            fetchSavedEnemies();
        } catch (err) {
            // Fallback: save to localStorage as wrapped full HTML
            const wrapped = wrapSavedHtml(content, title);
            saveLocally(title, wrapped);
            const el = document.getElementById(statusId);
            if (el) el.outerHTML = `<p style="color:var(--muted,#666);">Saved locally in your browser. To persist to disk, run the dev server and use the Create Page flow.</p>`;
        }
    }

    function saveLocally(name, html) {
        try {
            const arr = JSON.parse(localStorage.getItem('savedEnemies') || '[]');
            arr.unshift({ name: name || `enemy_${Date.now()}`, html });
            localStorage.setItem('savedEnemies', JSON.stringify(arr.slice(0, 200)));
            fetchSavedEnemies();
        } catch (e) { console.error('Failed to save locally', e); }
    }

    async function fetchSavedEnemies() {
        // Only operate on the NPC left-nav Saved subsection. Do not create any in-page lists.
        const npcNavList = document.querySelector('.nav-details.f-npc .nav-list');
        if (!npcNavList) return;

        // Ensure a Saved subsection exists inside the NPC nav
        let savedSection = npcNavList.querySelector(`#${NAV_SAVED_ID}`);
        if (!savedSection) {
            const li = document.createElement('li');
            li.className = 'nav-section';
            li.innerHTML = `
                <details class="nav-details f-npc-saved">
                    <summary class="nav-label"><span class="nav-icon">★</span><span>Saved</span></summary>
                    <ul id="${NAV_SAVED_ID}" class="nav-list" style="padding-left:0;margin:0;"></ul>
                </details>`;
            npcNavList.appendChild(li);
            savedSection = npcNavList.querySelector(`#${NAV_SAVED_ID}`);
        }
        savedSection.innerHTML = '';

        // Populate Saved subsection only from generator-created records stored in localStorage
        try {
            const genList = JSON.parse(localStorage.getItem('generatorSavedPages') || '[]');
            if (genList && genList.length) {
                // Optionally reconcile with server to get canonical names/hrefs
                let serverList = [];
                try {
                    const r2 = await fetch('/api/enemies');
                    if (r2.ok) serverList = await r2.json();
                } catch (e) { /* ignore */ }

                genList.forEach((g) => {
                    // avoid duplicates
                    if (savedSection.querySelector(`a[href="${g.href}"]`)) return;
                    const match = serverList.find(s => s.href === g.href || s.name === g.name);
                    const href = match ? match.href : (g.href || '#');
                    const name = match ? match.name : g.name;
                    const li = document.createElement('li');
                    li.style.listStyle = 'none';
                    li.style.marginBottom = '6px';
                    li.innerHTML = `<a class="nav-item" href="${href}" target="_blank"><span class="nav-icon">•</span><span class="nav-text">${escapeHtml(name)}</span></a>`;
                    savedSection.appendChild(li);
                });
            }
        } catch (e) { /* ignore */ }
    }

    function wrapSavedHtml(contentFragment, title) {
        const safeTitle = escapeHtml(title || 'Enemy');
        return `<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>${safeTitle} - Enemy</title>
    <link rel="stylesheet" href="/assets/style.css" />
    <link rel="stylesheet" href="/assets/components.css" />
    <link rel="stylesheet" href="/assets/landing-pages.css" />
    <script>window.SITE_BASE = "/"</script>
</head>
<body>
    <div class="layout">
        <main class="main">
            <article class="entity-page">
                <section class="entity">
                    <div class="entity-header" style="--header:url('/assets/ph-header.svg')">
                        <div class="entity-id">
                            <div class="entity-avatar"><img src="/assets/ph-avatar.svg" alt="${safeTitle}"></div>
                            <div class="entity-meta">
                                <div class="entity-name">${safeTitle}</div>
                                <div class="entity-sub">Generated Enemy</div>
                            </div>
                        </div>
                    </div>
                </section>
                <div class="entity-body">
                    <section id="overview">
                        ${contentFragment}
                    </section>
                </div>
            </article>
        </main>
    </div>
    <script src="/assets/site.js"></script>
</body>
</html>`;
    }

    async function handleSubmit(e) {
        e.preventDefault();
        const resultSection = document.getElementById('enemy-result');
        if (!resultSection) return;
        resultSection.innerHTML = '<em>Generating enemy...</em>';

        const lvlEl = document.getElementById('enemy-level');
        const classEl = document.getElementById('enemy-class');
        const srcEl = document.getElementById('enemy-source');
        const level = lvlEl ? parseInt(lvlEl.value, 10) || 1 : 1;
        const enemyClass = classEl ? classEl.value || 'minion' : 'minion';
        const source = srcEl ? srcEl.value || 'homebrew' : 'homebrew';
        const cr = levelToCR(level);

        if (source === 'open5e') {
            try {
                const r = await fetch(`https://api.open5e.com/monsters/?challenge_rating=${cr}`);
                const data = await r.json();
                if (!data.results || !data.results.length) {
                    resultSection.innerHTML = 'No monsters found for this level in Open5e. Trying homebrew...';
                    await fetchHomebrewAndRender(level, enemyClass);
                    return;
                }
                const monster = data.results[Math.floor(Math.random() * data.results.length)];
                renderEnemyInto(resultSection, monster, level, enemyClass);
            } catch (err) {
                resultSection.innerHTML = 'Error fetching enemy data from Open5e. Trying homebrew...';
                await fetchHomebrewAndRender(level, enemyClass);
            }
        } else {
            await fetchHomebrewAndRender(level, enemyClass);
        }
    }

    async function fetchHomebrewAndRender(level, enemyClass) {
        const resultSection = document.getElementById('enemy-result');
        try {
            const r = await fetch('/assets/homebrew-enemies.json');
            const data = await r.json();
            const matches = (data || []).filter(e => Number(e.level) === Number(level) && (e.class || '') === enemyClass);
            if (!matches.length) {
                resultSection.innerHTML = 'No homebrew enemies found for this level/class.';
                return;
            }
            const enemy = matches[Math.floor(Math.random() * matches.length)];
            renderEnemyInto(resultSection, enemy, level, enemyClass);
        } catch (err) {
            resultSection.innerHTML = 'Error loading homebrew enemies.';
        }
    }

    // init on DOM ready
    window.addEventListener('DOMContentLoaded', async () => {
        const form = document.getElementById('enemy-form');
        if (form) form.addEventListener('submit', handleSubmit);
        // populate saved-enemies list if present
        await checkBackend();
        fetchSavedEnemies();
    });

})();
